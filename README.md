# Asst1-Malloc

Developed with https://github.com/rajdesai925/

This implementation of malloc() and free() works by simulating a block of memory using an array.

The memory array is initialized with metadata which indicates that there is one free block available. Metadata consists of a 1-byte character, 'f' or 'd', to indicate whether the block of memory is free or allocated for data and a 4-byte integer which stores the size of the block of memory (not including the size of the metadata). For example, when memory is initialized, the first 5 bytes of the array are set to "f4091" assuming the size of the memory array is set to 4096 bytes. If 100 bytes of data were then allocated, the layout of the memory would be "d100" in the first 5 bytes followed by 100 bytes of allocated space for data. After these 100 bytes, another 5 bytes would store "f3986" (4096 bytes total - 5 bytes metadata - 100 bytes allocated for data - 5 bytes metadata = 3986 bytes remaining). The malloc() function works as a "first free" algorithm, meaning it selects the first free block of sufficient size to allocate for data. If no sufficently sized blocks are found, no memory is allocated and an error is reported(malloc also returns NULL to let the user's code know there was an issue). A request for less than one byte to be allocated will also report an error. Malloc() returns a pointer to the first byte of the allocated data block.

The free() function will only free pointers that were allocated by malloc(). The function searches through the memory array for blocks of data and compares the pointer to the first byte of that data with the pointer passed to it. If the pointers do match, we simply change the the metadata to indicate that the block is free instead of data. After doing this, we call a helper function, combine_free(), that searches through the memory to determine whether there are any consecutive free blocks in memory, as they need to be combined in order to ensure we can store as large of a chunk of data as possible. combine_free() works by checking if each block of data is free and if it is it jumps to the next block of data. If that block of data is also free, it adds the size of that block of data and that block's metadata to the size of the original free block. It continues to do that until the next block it finds is a data block. After that is continues checking the rest of the array. combine_free() takes no inputs and does not return anything. We chose to have it be a separate method that goes through the whole array as it made the code simpler and cleaner than if we had it keep track of multiple things that would otherwise be necessary. combine_free() takes no inputs and returns nothing.

If the pointers did not match, it continues through the array until reaching the last block in memory. At this point the code has checked all data in the memory and can be certain that it cannot be freed. These pointers that were not allocated by malloc(), already had been freed, or were not pointers in the first place will cause an error will be reported. Our free function takes a pointer as an input and returns an int. In addition to printing out an error message, the code also returns 0 if the function failed to free the pointer that was passed and 1 if it was successful.
